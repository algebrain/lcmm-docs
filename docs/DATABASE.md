# Документация: работа с БД в модулях LCMM

Этот документ описывает практический стандарт работы с БД в LCMM:
1. как писать модуль так, чтобы он работал и с `SQLite`, и с основной БД;
2. как безопасно управлять схемой через миграции;
3. в каком порядке запускать приложение, чтобы не получить "живой API с ломаной схемой".

## 1. Базовые правила работы с БД

1. Реализация для `SQLite` пишется первой и считается эталоном.
2. Реализация для основной БД обязательна для модулей, которым нужна БД.
3. Бизнес-логика не должна знать тип БД. Доступ к данным идет через абстракцию.
4. Тесты должны быть интеграционными, без моков БД.
5. Один и тот же набор тестов должен запускаться и на `SQLite`, и на основной БД (меняется только конфиг).
6. Если основной БД пока нет, тесты на `SQLite` считаются корректной базовой реализацией.

## 2. Слой абстракции без глубоких папок

Чтобы не усложнять структуру, абстракцию и обе реализации можно держать в одном namespace (например, `my-module.db`).

```clojure
(ns my-module.db
  (:require [next.jdbc :as jdbc]))

(defprotocol Store
  (get-user [this user-id])
  (put-user! [this user]))

(defn make-sqlite-store [{:keys [datasource]}]
  (reify Store
    (get-user [_ user-id]
      (first (jdbc/execute! datasource
                            ["select id, name from users where id = ?" user-id])))
    (put-user! [_ user]
      (jdbc/execute! datasource
                     ["insert into users (id, name) values (?, ?)"
                      (:id user) (:name user)])
      user)))

(defn make-pg-store [{:keys [datasource]}]
  (reify Store
    (get-user [_ user-id]
      (first (jdbc/execute! datasource
                            ["select id, name from users where id = ?" user-id])))
    (put-user! [_ user]
      (jdbc/execute! datasource
                     ["insert into users (id, name) values (?, ?)"
                      (:id user) (:name user)])
      user)))
```

Модуль получает `store` как зависимость и работает только через протокол.

## 3. Подключение реализации через конфиг

```clojure
(defn make-store [config]
  (case (:db/engine config)
    :sqlite   (db/make-sqlite-store {:datasource (:sqlite/ds config)})
    :postgres (db/make-pg-store {:datasource (:pg/ds config)})))
```

Пример значений:
1. `:db/engine :sqlite`
2. `:db/engine :postgres`

## 4. Почему миграции обязательны

Без миграций схема БД "плывет": разные окружения начинают жить с разными таблицами и индексами.
Результат обычно один: API запущен, но часть операций падает непредсказуемо.

Поэтому в LCMM схема БД должна меняться только через миграции с фиксированной историей.

## 5. Выбранный инструмент миграций

Для миграций используется внешний инструмент `migratus`.
В рамках LCMM мы не разрабатываем собственный мигратор, а фиксируем правила применения `migratus`.

## 6. Стандартный цикл запуска: migrate -> verify -> start

Обязательный порядок:
1. `backup` (для SQLite перед критичными изменениями).
2. `migratus migrate`.
3. `migratus status` (проверка, что схема в ожидаемом состоянии).
4. `start api`.

Запуск API до применения миграций не допускается.

## 7. Практика для SQLite

Для простых приложений с SQLite:
1. перед изменениями схемы делать копию файла БД;
2. применять миграции только после успешного backup;
3. при сбое миграции использовать backup для восстановления, если откат миграцией невозможен.

## 8. Runbook: если миграция упала

Минимальный порядок действий:
1. Зафиксировать, на какой миграции упал `migratus`.
2. Остановить дальнейшие деплой-действия.
3. Проверить, были ли частично применены изменения схемы/данных.
4. Если есть корректный rollback-скрипт, выполнить откат.
5. Если откат невозможен, восстановить БД из backup.
6. Повторить `migratus status` и убедиться, что состояние консистентно.
7. Только после этого возвращаться к `migratus migrate -> start api`.

## 9. Что нельзя делать в миграциях

1. Нельзя запускать API с "ожиданием, что миграции применим позже".
2. Нельзя править уже примененную миграцию задним числом.
3. Нельзя смешивать неатомарные изменения схемы и данных без понятного пути отката.
4. Нельзя запускать миграции без проверки статуса после применения.

## 10. Чек-лист перед запуском API

Перед запуском убедитесь:
1. backup сделан (для SQLite, если изменение рискованное);
2. `migratus migrate` выполнен без ошибок;
3. `migratus status` подтверждает ожидаемую версию;
4. smoke-check ключевых таблиц проходит;
5. только после этого включается API-трафик.

## 11. Тестирование DB-слоя

Рекомендация:
1. в обычном CI прогонять интеграционные тесты на `SQLite`;
2. отдельным запуском прогонять тот же набор тестов на основной БД.

Пример схемы теста:

```clojure
(defn with-store [config f]
  (let [store (make-store config)]
    (f store)))

(deftest user-store-test
  (with-store test-config
    (fn [store]
      (is (nil? (get-user store 1)))
      (put-user! store {:id 1 :name "Alice"})
      (is (= "Alice" (:name (get-user store 1)))))))
```
