# Документация: Модули Системы

Этот документ описывает стандартный подход к созданию модулей в системе. Модуль представляет собой самодостаточную единицу бизнес-логики, которая взаимодействует с другими частями системы исключительно через `event-bus` и `Router`. Такой подход обеспечивает высокую степень изоляции и облегчает разработку, тестирование и масштабирование.

## 1. Анатомия Модуля

Каждый модуль должен предоставлять функцию инициализации `init!`, которая служит его точкой входа. Эта функция отвечает за настройку модуля, включая регистрацию HTTP-маршрутов и подписку на события шины.

### Функция `init!`

*   **Сигнатура:** `(defn init! [deps])`
*   **Параметр `deps`:** Карта зависимостей, которая всегда содержит следующие обязательные компоненты:
    *   `:bus` — экземпляр `event-bus` (см. `BUS.md`)
    *   `:router` — экземпляр `Router` (см. `ROUTER.md`)
    *   `:logger` — функция-логгер, соответствующая стандартному интерфейсу (см. `LOGGING.md`)
*   **Ответственность:** Внутри `init!` модуль должен:
    *   Зарегистрировать свои HTTP-маршруты в переданном `:router`.
    *   Подписаться на необходимые события в переданном `:bus`.
    *   Использовать переданный `:logger` для всех внутренних лог-сообщений.

**Пример структуры модуля:**

```clojure
(ns my-module.core
  (:require [lcmm.bus :as bus]
            [lcmm.router :as router]))

;; Внутренние функции-обработчики HTTP-запросов
(defn- handle-get-resource [bus logger req]
  (logger :info {:component ::my-module, :event :get-resource-request, :path (:uri req)})
  ;; ...логика получения ресурса...
  (bus/publish bus :my-module/resource-accessed {:resource-id "abc"} {:module ::my-module}) ; Пример публикации события
  {:status 200 :body "Resource data"})

;; Внутренние функции-обработчики событий шины
(defn- handle-resource-updated [bus logger envelope]
  (logger :info {:component ::my-module, :event :resource-updated-event, :payload (:payload envelope)})
  ;; ...логика реакции на обновление ресурса...
  )

(defn init!
  "Инициализирует модуль, регистрируя маршруты и подписываясь на события."
  [{:keys [bus router logger]}]
  (logger :info {:component ::my-module, :event :module-initializing})

  ;; 1. Регистрация HTTP-маршрутов
  (router/add-route! router
                     :get "/api/my-module/resource"
                     (partial handle-get-resource bus logger) ; Частичное применение зависимостей
                     {:name ::get-resource})

  ;; 2. Подписка на события шины
  (bus/subscribe bus
                 :some-other-module/resource-updated
                 (fn [bus envelope]
                   (handle-resource-updated bus logger envelope)))

  (logger :info {:component ::my-module, :event :module-initialized}))
```

## 2. Обработка HTTP-запросов

Модули взаимодействуют с внешним миром через HTTP. Все HTTP-маршруты должны быть зарегистрированы в экземпляре `Router`, который передается в `init!`.

*   **Использование `router/add-route!`**: Для регистрации маршрутов, как показано в примере выше.
*   **Разделение ответственности**: Обработчики HTTP-запросов должны выполнять только ту часть логики, которая касается непосредственной обработки запроса и формирования ответа. Длительные операции и "побочные эффекты" должны быть вынесены в асинхронные обработчики событий, которые публикуются в `event-bus`.

## 3. Реакция на События

Модули реагируют на внутренние события системы, подписываясь на них через `event-bus`.

*   **Использование `bus/subscribe`**: Для подписки на события, как показано в примере выше.
*   **Изолированность обработчиков**: Обработчики событий должны быть изолированными функциями, выполняющими свою специфическую задачу в ответ на событие.
*   **Поддержание причинности (`Causation`)**: Если ваш обработчик событий публикует новые события, всегда передавайте `:parent-envelope` из входящего конверта и `:module`, чтобы `event-bus` мог отслеживать цепочку причинно-следственных связей.

## 4. Логирование

Для обеспечения централизованного и структурированного логирования, каждый модуль должен использовать функцию `logger`, переданную при инициализации.

*   **Стандартный интерфейс логгера**: Функция `logger` принимает уровень логирования (keyword) и карту данных.
*   **Структура лог-сообщений**: Все лог-сообщения **должны быть картами**. Обязательно включайте ключи `:component` (с именем вашего модуля, например, `::my-module`) и `:event` для лучшей категоризации и поиска логов.
*   **Пример**: `(logger :info {:component ::my-module, :event :user-data-processed, :user-id 123})`.

## 5. Работа с базой данных (если модулю нужна БД)

Если модуль работает с базой данных, он обязан поддерживать **две реализации**:
*   `SQLite` (пишется первой и служит эталоном для тестов и документации).
*   Основная БД (например, PostgreSQL).

Правила:
*   Логика модуля **не зависит** от конкретной БД. Для этого используется слой абстракции (см. `DATABASE.md`).
*   **Тесты только интеграционные**, никаких моков.
*   Один и тот же набор тестов должен запускаться и на `SQLite`, и на основной БД, меняется только одна настройка.
*   Если подключения к основной БД пока нет, тесты пишутся и гоняются на `SQLite`. Это считается корректной базовой реализацией.

Смотри подробные правила и пример абстракции в `DATABASE.md`.

## 6. Конфигурирование модулей

Для конфигурирования модулей используйте библиотеку [`lcmm-configure`](https://github.com/algebrain/lcmm-configure). Правила и примеры описаны в [`./CONFIGURE.md`](./CONFIGURE.md) и [`./CONFIGURE_ADMIN.md`](./CONFIGURE_ADMIN.md). Модуль не должен самостоятельно реализовывать логику сборки конфига.

Цель — максимально простой опыт для администраторов: один понятный порядок, минимум "магии".

## 7. Сборка и Запуск Системы

Основная часть приложения (`-main` функция) отвечает за инициализацию всех ключевых компонентов и модулей:

1.  **Создание базовых сервисов**: Создаются экземпляры `event-bus`, `Router` и глобальный `logger`.
2.  **Инициализация модулей**: Для каждого модуля вызывается его функция `init!`, которой передаются созданные базовые сервисы в карте зависимостей.
3.  **Запуск веб-сервера**: `Router` компилируется в финальный `Ring-handler` (с применением глобального middleware, если необходимо) и передается веб-серверу (например, `http-kit`).

Этот подход гарантирует, что каждый модуль получает все необходимые зависимости "сверху" (Inversion of Control) и функционирует как независимая, но интегрированная часть общей системы.
