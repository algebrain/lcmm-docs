# SECURE_APP: безопасность на уровне приложения

Версия: `1.1-draft`

Этот документ описывает, что должно быть реализовано на уровне всего приложения (общий HTTP-слой, middleware, защита входа).

## 1. Термины (кратко)

1. `trusted proxy` — доверенный прокси, чей заголовок IP можно использовать.
2. `fail-open` — при сбое механизма защиты запрос пропускается.
3. `fail-closed` — при сбое механизма защиты запрос блокируется.
4. `anti-enumeration` — защита от угадывания по различиям ответов.

## 2. Обязательные меры

1. Обязательная валидация входа на границе HTTP (path/query/body).
2. App-level сессионный auth middleware.
3. Детект атакующих паттернов по IP в окне времени.
4. Временный ban IP по порогу.
5. Rate limit и базовые DoS-ограничения.
6. Единый безопасный error-contract и `correlation-id`.
7. Redaction до логирования.
8. Security headers.

## 3. Валидация входа (первый приоритет)

1. Валидация выполняется до вызова модульного handler.
2. Невалидный запрос останавливается на входе (`400/422`).
3. На уровне приложения должны действовать глобальные лимиты:
- `max_body_bytes = 1MB`
- `max_string_length = 1024`
- `max_array_items = 100`
4. Разрешенные `Content-Type` и HTTP-методы задаются явно.

## 4. App-level auth middleware

1. Модуль `auth` экспортирует middleware.
2. Middleware проверяет сессию.
3. При успехе добавляет в request `:auth/user`.
4. Публичные маршруты задаются allow-list, остальное закрыто.

### 4.1 Сессионная безопасность

1. Cookie: `HttpOnly`, `Secure` (в HTTPS), `SameSite`.
2. Ротация `session-id` после входа.
3. CSRF-защита для state-changing endpoint-ов.

## 5. Детект и временный ban IP

Считать по IP в окне `5 min`:
1. ошибки валидации;
2. ответы `401/403`;
3. повторяющиеся подозрительные запросы.

Стартовые пороги:
1. `validation_error_threshold = 20 / 5 min`
2. `auth_error_threshold = 20 / 5 min`

При превышении:
1. активировать ban;
2. вернуть `429` (или `403` по принятой политике);
3. снять ban автоматически через `ban_ttl = 15 min`.

Должен быть технический allow-list для мониторинга/служебных проверок.

## 6. Политика IP за прокси

1. IP из `X-Forwarded-For` использовать только от `trusted proxy`.
2. Иначе использовать прямой IP соединения.
3. Если политика прокси не настроена, IP-ban отключать нельзя молча.

## 7. Минимальная DoS-защита

1. `rate_limit = 60 req/min per IP`
2. лимит размера тела запроса;
3. таймаут обработки запроса;
4. лимит одновременных запросов на инстанс.

## 8. Режим отказа защит

Для limiter/detector/ban выбрать явно:
1. `fail-open`
2. `fail-closed`

Рекомендуемый старт для малого проекта: `fail-open` + алерт о деградации защиты.

## 9. Единый безопасный ответ ошибки

Минимальный формат:
1. `code`
2. `message`
3. `details` (опционально)
4. `correlation-id`

Запрещено отдавать наружу:
1. stacktrace;
2. SQL-текст;
3. внутренние пути/детали инфраструктуры;
4. секретные значения.

### 9.1 Anti-enumeration

1. Для auth-ошибок использовать единый ответ без подсказки "пользователь существует/не существует".
2. Коды и тексты не должны помогать перебору учетных данных.

## 10. Security headers

1. `X-Content-Type-Options: nosniff`
2. `X-Frame-Options: DENY` (или CSP-политика)
3. `Referrer-Policy`
4. `Strict-Transport-Security` (если HTTPS)

## 11. Redaction policy

Маскировать минимум:
1. `password`
2. `token`
3. `secret`
4. `api-key`
5. `authorization`
6. `cookie`

## 12. Проверка (чек-лист)

1. Невалидный payload отклоняется на входе.
2. Защищенный endpoint без сессии дает `401`.
3. Для auth-ошибок нет подсказок для перебора.
4. После порога ошибок IP получает временный ban.
5. После TTL ban снимается.
6. Burst-запросы упираются в rate limit.
7. За прокси корректно определяется клиентский IP.
8. Security headers присутствуют в ответах.
9. При деградации limiter/detector поведение соответствует выбранному fail-режиму.

## 13. Рекомендуемый toolchain (стабильные библиотеки)

1. HTTP-валидация:
- `metosin/reitit` + `metosin/malli`.

2. Сессии, CSRF, security headers:
- `ring/ring-core`;
- `ring/ring-defaults`.

3. Auth middleware:
- базовый собственный middleware модуля `auth`;
- при необходимости `buddy/buddy-auth`.

4. Хранилище счетчиков/TTL для limiter/ban:
- `clj-commons/carmine` + Redis.

5. Для детекта+ban как единой политики требуется отдельный слой (см. план `lcmm-guard` в `docs.local/INDEX.md`).
