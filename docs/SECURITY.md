# SECURITY: минимальный baseline для LCMM API

Версия: `1.0-draft`

## 1. Назначение документа

Этот документ фиксирует минимальные правила безопасности для простого LCMM-сервиса.
Цель: дать реалистичный baseline, который один разработчик может внедрить быстро и без корпоративной перегрузки.

## 2. Термины

- `Authentication` (аутентификация): кто вызывает API.
- `Authorization` (авторизация): что этому вызывающему разрешено.
- `Redaction`: маскирование чувствительных данных в логах и ошибках.
- `correlation-id`: идентификатор запроса/цепочки для трассировки.
- `Error contract`: единый формат ошибки HTTP-API.

## 3. Что обязательно сделать (минимум)

1. Защитить непубличные endpoint-ы проверкой доступа (минимум API-key).
2. Явно разделить маршруты на публичные и защищенные.
3. Использовать единый безопасный формат ошибок.
4. Никогда не отдавать во внешний ответ stacktrace и внутренние детали исключений.
5. Маскировать секреты в логах и в `details` ошибок.
6. Передавать `correlation-id` в каждой ошибке.

## 4. Минимальный профиль authN/authZ

### 4.1 Основной подход для монолита

Для простого LCMM-монолита основной вариант:
1. есть модуль `auth`;
2. модуль `auth` экспортирует middleware уровня приложения;
3. middleware проверяет сессию;
4. при успехе добавляет в request готового пользователя (например, `:auth/user`);
5. бизнес-модули читают только `:auth/user` и не реализуют свою auth-логику.

Публичные endpoint-ы перечисляются явно (deny-by-default для всего остального).

### 4.2 Практический пример (псевдокод)

```clojure
(defn wrap-session-auth [handler {:keys [load-session-user]}]
  (fn [req]
    (if-let [user (load-session-user req)]
      (handler (assoc req :auth/user user))
      {:status 401
       :body {:code "auth/unauthorized"
              :message "Unauthorized"
              :correlation-id (get req :correlation-id)}})))
```

Важно: middleware подключается на уровне приложения, а не отдельных модулей.

## 5. Redaction policy (маскирование секретов)

### 5.1 Что маскировать обязательно

Ключи и поля, содержащие:
1. `password`
2. `token`
3. `secret`
4. `api-key`
5. `authorization`
6. `cookie`

### 5.2 Правило для логов и ошибок

1. В логах и error-body чувствительные значения заменяются на `***`.
2. Маскирование применяется рекурсивно (вложенные map/JSON/EDN).
3. Если есть сомнение, считать значение секретом и маскировать.

### 5.3 Пример

Вход:
```edn
{:email "a@b.com" :password "qwerty" :token "abcd"}
```

Выход после redaction:
```edn
{:email "a@b.com" :password "***" :token "***"}
```

## 6. Политика безопасных ошибок (error-response policy)

### 6.1 Единый формат ошибки

Минимальный формат:
```json
{
  "code": "validation/failed",
  "message": "Invalid request",
  "details": {},
  "correlation-id": "..."
}
```

### 6.2 Что запрещено отдавать наружу

1. stacktrace;
2. SQL-текст запросов;
3. внутренние пути файлов/структуру проекта;
4. сырые сообщения исключений, содержащие секреты.

### 6.3 Что можно логировать внутри

1. технический текст ошибки;
2. stacktrace;
3. диагностические поля запроса.

Но перед логированием обязателен redaction.

## 7. Защита operational endpoint-ов

Минимальная рекомендация:
1. `GET /healthz` можно оставить открытым только во внутреннем контуре.
2. `GET /readyz` лучше ограничивать внутренним доступом (или закрывать тем же auth-механизмом).
3. Если endpoint доступен снаружи, ответ должен быть минимальным, без утечки деталей зависимостей.

## 8. Как проверить, что baseline внедрен

Проверка 1: доступ без ключа
1. Вызвать защищенный endpoint без API-key.
2. Ожидать `401` и корректный error-body с `correlation-id`.

Проверка 2: утечка ошибок
1. Искусственно вызвать исключение в endpoint.
2. Убедиться, что клиент не видит stacktrace и внутренние детали.

Проверка 3: redaction
1. Отправить запрос с полями `password/token`.
2. Проверить логи: чувствительные значения должны быть `***`.

Проверка 4: публичные маршруты
1. Проверить, что только явно отмеченные endpoint-ы доступны без auth.
2. Остальные должны требовать auth.

## 9. Частые ошибки и как их избежать

1. Ошибка: "временно" оставить endpoint открытым и забыть.
Решение: правило deny-by-default, публичные маршруты только через явный allow-list.

2. Ошибка: логировать весь request/body целиком.
Решение: логировать только нужные поля + redaction перед записью.

3. Ошибка: разный формат ошибок в разных модулях.
Решение: единый error-contract middleware.

4. Ошибка: проверять сессию в каждом модуле отдельно.
Решение: централизовать проверку в одном app-level middleware из модуля `auth`.

## 10. Границы документа

Этот документ не покрывает:
1. корпоративные IAM/SSO/PKI;
2. полный threat modeling;
3. сложные ролевые модели enterprise-уровня.

Он покрывает только минимальный, практичный baseline для малого LCMM API.

## 11. Мини-чек-лист перед первым релизом

1. Все непубличные endpoint-ы защищены auth.
2. Публичные endpoint-ы перечислены явно.
3. Error contract единый и содержит `correlation-id`.
4. Клиенту не уходит stacktrace.
5. Redaction работает для `password/token/secret/api-key`.
6. Секреты не лежат в репозитории и не печатаются в логах.
