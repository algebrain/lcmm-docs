# SECURITY: минимальная активная защита LCMM API

Версия: `1.2-draft`

## 1. Назначение

Этот документ задает минимальный, практический baseline безопасности для небольшого живого приложения.
Фокус: закрыть наиболее частые реальные риски без корпоративной перегрузки.

## 2. Термины (кратко)

1. `allow-list` — список явно разрешенных значений.
2. `anti-enumeration` — защита от перебора и угадывания по различиям ответов.
3. `reverse proxy` — промежуточный сервер перед приложением.
4. `trusted proxy` — доверенный прокси, чьи заголовки IP можно использовать.
5. `fail-open` — при сбое защитного механизма запрос пропускается.
6. `fail-closed` — при сбое защитного механизма запрос блокируется.
7. `security headers` — HTTP-заголовки базовой защиты браузерного клиента.

## 3. Обязательный минимум (в порядке приоритета)

1. Обязательная валидация входных данных endpoint-ов.
2. Минимальная защита от инъекций.
3. Детект повторяющихся атакующих запросов.
4. Временный ban IP при превышении порога.
5. Минимальная DoS-защита.
6. App-level сессионный auth middleware.
7. Redaction и безопасный error-response.

## 4. Обязательная валидация данных endpoint-ов

### 4.1 Что валидировать

1. `path` параметры;
2. `query` параметры;
3. `body` запроса;
4. заголовки, если они влияют на поведение.

### 4.2 Правила

1. Валидация выполняется до бизнес-логики.
2. Невалидный запрос не передается в DB/сервисный слой.
3. На невалидный ввод возвращается `400` или `422` по единому error-contract.
4. Должны быть лимиты длины строк, размера массивов и размера body.
5. Разрешенные `Content-Type` задаются явно.
6. Разрешенные HTTP-методы задаются явно.

### 4.3 Минимальные дефолты

1. `max_body_bytes = 1MB`
2. `max_string_length = 1024`
3. `max_array_items = 100`
4. `allowed_content_types = [application/json]`

## 5. Минимальная защита от инъекций

1. SQL-запросы только параметризованные.
2. Запрещена строковая конкатенация SQL с пользовательским вводом.
3. Для сортировок/фильтров использовать allow-list полей и направлений.
4. Не выполнять пользовательский ввод как код.
5. Регулярные выражения от пользователя ограничивать (длина/сложность/таймаут).

## 6. Детект попыток взлома

В скользящем окне времени по IP считать:
1. ошибки валидации;
2. ответы `401`/`403`;
3. повторяющиеся подозрительные запросы.

При срабатывании порога писать событие безопасности в лог:
1. IP;
2. endpoint;
3. тип события;
4. `correlation-id` (если есть).

### 6.1 Стартовые пороги

1. `validation_error_threshold = 20 / 5 min per IP`
2. `auth_error_threshold = 20 / 5 min per IP`

## 7. Временный ban IP

1. При превышении порога активируется временный ban.
2. Ответ при бане: `429` (или `403`, если так выбрано в политике).
3. Ban снимается автоматически по TTL.
4. События ban/unban логируются.
5. Должен быть технический allow-list (например, внутренний мониторинг и служебные проверки).

### 7.1 Дефолт

1. `ban_ttl = 15 min`

## 8. Минимальная DoS-защита

1. Rate limit по IP.
2. Лимит размера тела запроса.
3. Таймаут обработки запроса.
4. Ограничение одновременных запросов на инстанс.

### 8.1 Дефолт

1. `rate_limit = 60 req/min per IP`

## 9. Политика IP за прокси

1. Источник IP определяется через `X-Forwarded-For` только если запрос пришел от `trusted proxy`.
2. Если доверенного прокси нет, используется прямой IP соединения.
3. Политика должна быть явно настроена, иначе возможны ложные баны.

## 10. Режимы отказа защиты

Для rate-limit/detector/ban надо явно выбрать режим:
1. `fail-open` (доступнее, но слабее защита);
2. `fail-closed` (строже защита, но выше риск ложных блокировок).

Рекомендуемый дефолт для малого проекта: `fail-open` + обязательный алерт о деградации защиты.

## 11. App-level auth для монолита

Основной подход:
1. модуль `auth` экспортирует middleware уровня приложения;
2. middleware проверяет сессию;
3. при успехе добавляет в request `:auth/user`;
4. бизнес-модули используют `:auth/user` и не проверяют сессию повторно.

### 11.1 Безопасность сессии

1. Cookie: `HttpOnly`, `Secure` (в HTTPS), `SameSite`.
2. Ротация `session-id` после успешного входа.
3. Для state-changing endpoint-ов должна быть CSRF-защита.

## 12. Anti-enumeration и безопасные ошибки

### 12.1 Anti-enumeration

1. Ошибки входа должны быть унифицированы по тексту/коду.
2. Нельзя раскрывать, существует ли конкретный пользователь/идентификатор.

### 12.2 Error-response policy

В ответ наружу не отправлять:
1. stacktrace;
2. SQL-текст;
3. внутренние пути/детали инфраструктуры;
4. сырые сообщения исключений с секретами.

Минимальный error-body:
1. `code`
2. `message`
3. `details` (опционально)
4. `correlation-id`

## 13. Redaction

Маскировать минимум:
1. `password`
2. `token`
3. `secret`
4. `api-key`
5. `authorization`
6. `cookie`

## 14. Логи безопасности и хранение

1. Логировать события детекта, ban/unban, ошибки auth, ошибки валидации.
2. Хранить security-логи ограниченное время (например, `30 days`).
3. Логи должны быть пригодны для разбора инцидента и поиска ложных срабатываний.

## 15. Проверка защиты (обязательные сценарии)

1. Невалидный payload отклоняется до бизнес-логики.
2. Инъекционный ввод не меняет структуру SQL-запроса.
3. Серия ошибок валидации с одного IP попадает в детект.
4. После превышения порога IP получает временный ban.
5. После TTL ban снимается автоматически.
6. При burst-нагрузке срабатывает rate limit и сервис остается доступным.
7. За прокси корректно определяется клиентский IP.
8. При auth-ошибках ответы не раскрывают, существует ли пользователь.
9. Security headers присутствуют в ответах.

## 16. Security headers (минимум)

1. `X-Content-Type-Options: nosniff`
2. `X-Frame-Options: DENY` (или эквивалентная CSP-политика)
3. `Referrer-Policy: no-referrer` (или эквивалентная строгая политика)
4. `Strict-Transport-Security` (когда используется HTTPS)

## 17. Частые ошибки

1. Валидация только в бизнес-логике, а не на входе endpoint.
2. Частичное использование параметризованных SQL.
3. Логи без redaction.
4. Разный формат ошибок между endpoint-ами.
5. Проверка сессии внутри каждого модуля, а не на уровне приложения.
6. Бан по IP без учета reverse proxy.
7. Отсутствие явной политики fail-open/fail-closed.

## 18. Что уже закрывается стабильными библиотеками

1. Валидация endpoint-данных:
- `metosin/reitit` (coercion) + `metosin/malli` (схемы и валидация).

2. Безопасная работа с SQL и снижение риска инъекций:
- `next.jdbc` (параметризованные запросы);
- `seancorfield/honeysql` (безопасная сборка SQL без строковой конкатенации).

3. Сессии, CSRF и часть security headers:
- `ring/ring-core`;
- `ring/ring-defaults` (дефолтные middleware, включая anti-forgery и заголовки защиты).

4. Auth-интеграция (если нужен готовый слой поверх сессий):
- `buddy/buddy-auth`.

5. Счетчики/окна/TTL для limiter и ban-хранилища:
- `clj-commons/carmine` (Redis, `INCR`/`EXPIRE` паттерны).

## 19. Что не закрыто готовыми библиотеками "из коробки"

Для небольшого проекта обычно нет одной готовой библиотеки, которая сразу и согласованно дает:
1. детект атакующих паттернов (валидация + auth + подозрительные повторы);
2. временный ban IP с общей политикой исключений;
3. единый fail-open/fail-closed policy;
4. согласованную интеграцию с логированием и security-событиями.

Для этого нужен отдельный слой/библиотека проекта (см. план `lcmm-guard` в `docs.local/INDEX.md`).
